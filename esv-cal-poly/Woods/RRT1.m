%RANDOMLY-EXPLORING RANDOM TREE ALGORITHM
%WILDCARD ENGINEERING

%VARIABLES*****************************************************************
GOAL= [3, 35];          %GOAL NODE FOR THE RRT [x,y]


GOAL_DIST=0;            %DISTANCE TO THE GOAL NODE [ft]
TREE=zeros(5000,3);      %NODE TREE [x, y, connecting node(cn)]
FINAL_TREE=zeros(5000,2);%STORES THE FINAL ROUTE [x,y]
FINAL_NODES=0;          %STORES THE FINAL NUMBER OF NODES USED
NODES=1;                %NUMBER OF NODES IN THE TREE
NODE_DIST=5;            %DISTANCE BETWEEN NODES [ft]
RAND_NODE=[0,0];        %LOCATION OF THE RANDOM NODE (X, Y)
CLOSE_NODE=[0,0];       %CLOSEST NODE IN [TREE] TO THE RANDOM NODE [x,y,cn]
TEMP_NODE=[0,0,0];      %TEMPORARY NODE [x, y, cn]
THETA=0;                %ANGLE TO THE TEMPORARY NODE  [radians]
RAND_GO=0;              %SET TO 1 TO BEGIN CHECKING RANDOM NODE
RAND_DIST=0;            %DISTANCE TO THE RANDOM NODE FROM THE CLOSEST NODE [ft]
DONE=0;                 %TELLS THE RRT LOOP TO END
LOOP=0;                 %testing variable
CONNECTING_NODE=0;      %INITIAL CONNECTION
TOT_TREE=zeros(5000,2); %STORRES ALL TESTED NODES
TOT_NODES=1;            %STORES THE TOTAL NUMBER OF NODES TESTED
RAND_TREE=zeros(5000,2);%STORES THE RANDOM NODES USED
RAND_TOT=0;             %STORES THE NUMBER OF RANDOM NODES USED
ITERATIONS=0;           %TOTAL NUMBER OF ITERATIONS UNTIL PATH COMPLETION
NOGOGO=0;               %FLAG HELD HIGH IF PATH IS NOT FEASIBLE


%RANDOM NODES ARE SEARCHED FOR IN THE FOLLOING RECTANGLE
X1=-6;                  %LOWER LIMIT ON THE X AXIS  [ft]
X2=6;                   %UPPER LIMIT ON THE X AXIS  [ft]
Y1=35;                  %UPPER LIMIT ON THE Y AXIS  [ft]
Y2=2;                   %LOWER LIMIT ON THE Y AXIS  [ft]
RAND_SPACE=zeros(2,2);  %SCALAR AND OFFSETS [XSCALAR YSCALAR; XOFFEST YOFFSET]
%INITIALIZING RAND_SPACE
RAND_SPACE(1,1)=(X2-X1);    %XSCALAR             [ft]
RAND_SPACE(1,2)=(Y1-Y2);    %YSCALAR             [ft]     
RAND_SPACE(2,1)=X1;         %XOFFSET FROM ZERO   [ft]
RAND_SPACE(2,2)=Y2;         %YOFFSET FROM ZERO   [ft]


% %OBSTACLE SIZE CURRENTLLY MODELED AS A RECTANGLE
% OBSTACLE_SPACE=zeros(2,2); %OBSTACLE AREA
% OX1=-3;                    %THE OBSTACLE IS DEFINED BY A RECTANCLE
% OX2=3;                     %THESE VALUES WILL BE COMING FROM SENSORS 
% OY1=15;                     %AND WILL BE SUBJECT TO CHANGE WHEN THE OBSTACLE MOVES
% OY2=12;
% 
% %INITIAL POSITION OF OBSTACLE
% OBSTACLE_SPACE(1,1)=OX1;   
% OBSTACLE_SPACE(1,2)=OY1;
% OBSTACLE_SPACE(2,1)=OX2;
% OBSTACLE_SPACE(2,2)=OY2;

%INITITIAL POSITION OF VEHICLE
TREE(1,1)=-3;  %X
TREE(1,2)=2;  %Y

GOAL_DIST=((GOAL(1)-TREE(1,1))^2+(GOAL(2)-TREE(1,2))^2)^.5; %INITIAL DISTANCE TO THE GOAL

while (DONE==0)
    
    %TEST TO SEE IF STRAIGHT PATH IS POSSIBLE*************************
    while (RAND_GO==0)        %LOOP UNTIL AN OVERLAP IS DETECTED
        ITERATIONS=ITERATIONS+1;
        
        CLOSE_NODE=TREE(NODES,1:2);          %SETS NODE JUST ADDED TO THE CLOSEST NODE
                                           %TO TEST A STRAIGHT PATH FROM IT
        
                                           
        GOAL_DIST=((GOAL(1)-CLOSE_NODE(1))^2+(GOAL(2)-CLOSE_NODE(2))^2)^.5;  %DETERMINES THE DISTANCE TO THE GOAL
        
        %NOGOGO=testroute(TREE, GOAL_NODE, GOAL_DIST,0);
        
        %CHECK TO SEE IF THE GOAL HAS BEEN REACHED BY COMPARING
        %THE DISTANCE TO THE GOAL TO THE NODE DISTANCE
        if (GOAL_DIST<NODE_DIST) && NOGOGO==0
            TREE((NODES+1), 1:2)=GOAL;
            TREE((NODES+1),3)=NODES;
            DONE=1;
            NODES=NODES+1;
        else  
        
        %LOCATION OF TEMPORARY NODE IN THE DIRECTION OF THE GOAL
        TEMP_NODE(1)=CLOSE_NODE(1)+ NODE_DIST*(GOAL(1)-CLOSE_NODE(1))/GOAL_DIST;   %X
        TEMP_NODE(2)=CLOSE_NODE(2)+ NODE_DIST*(GOAL(2)-CLOSE_NODE(2))/GOAL_DIST;   %Y
        TEMP_NODE(3)=NODES;
        
        TOT_TREE(TOT_NODES,:)=TEMP_NODE(1:2);   %STORES THE TEMPORARY NODE
        TOT_NODES=TOT_NODES+1;                  %INCREMENTS THE TOTAL NUMBER OF NODES CHECKED
        NOGOGO=testroute(TREE, TEMP_NODE, NODE_DIST,0);
        end
        %DETERMINING IF TEMPORARY NODE IS INSIDE THE OBSTACLE SPACE
        %if ((TEMP_NODE(1)<OBSTACLE_SPACE(1,1))|| (TEMP_NODE(1)>OBSTACLE_SPACE(2,1))) || ((TEMP_NODE(2)>OBSTACLE_SPACE(1,2))|| (TEMP_NODE(2)<OBSTACLE_SPACE(2,2)))&&((DONE==0) && (NOGOGO==0))
        if (NOGOGO==0 && DONE == 0)    
            %NODES
            
            NODES = NODES + 1;                   %INCREMENT THE NODE COUNTER
            TREE(NODES, :)=TEMP_NODE;                      %NODE IS ADDED TO THE TREE
            %TREE(NODES, :)
        else
            RAND_GO=1;                           %OVERLAP DETECTED
    
        end
        
    end


    %CHECKING RANDOM NODES****************************************************
    while (RAND_GO==1)&&(DONE==0)
        
        ITERATIONS=ITERATIONS+1;
        %SETS A RANDOM NODE
        RAND_NODE(1)=RAND_SPACE(1,1)*rand+RAND_SPACE(2,1);    %X
        RAND_NODE(2)=RAND_SPACE(1,2)*rand+RAND_SPACE(2,2);    %Y 
        RAND_TOT=RAND_TOT+1;                                  %INCREMENTS THE NUMBER OF RANDOM NODES USED
        RAND_TREE(RAND_TOT,:)=RAND_NODE;
        %SOLVING FOR THE DISTANCE TO THE RANDOM NODE
        RAND_DIST=((RAND_NODE(1)-TREE(1,1))^2+(RAND_NODE(2)-TREE(1,2))^2)^.5; 
        
        %DETERMINING CLOSEST NODE TO THE GOAL
        for i=1:1:NODES
            %SOLVING FOR THE DISTANCE TO THE GOAL NODE
            TEMP_DIST=((RAND_NODE(1)-TREE(i,1))^2+(RAND_NODE(2)-TREE(i,2))^2)^.5; %DETERMINES THE DISTANCE TO THE CURRENT NODE IN [TREE]
            if (TEMP_DIST<=RAND_DIST)
                RAND_DIST=TEMP_DIST;               %MAKES THE CHECKED DISTANCE THE NEW DISTANCE
                CLOSE_NODE=TREE(i, 1:2);           %SETS THE CLOSEST NODE
                TEMP_NODE(3)=i;                    %MARKS WHAT NODE IT IS
            end
        end
        
        %LOCATION OF TEMPORARY NODE
        TEMP_NODE(1)=CLOSE_NODE(1) + NODE_DIST*(RAND_NODE(1)-CLOSE_NODE(1))/RAND_DIST;   %X
        TEMP_NODE(2)=CLOSE_NODE(2) + NODE_DIST*(RAND_NODE(2)-CLOSE_NODE(2))/RAND_DIST;   %Y
        
        TOT_TREE(TOT_NODES,:)=TEMP_NODE(1:2);   %STORES THE TEMPORARY NODE
        TOT_NODES=TOT_NODES+1;                  %INCREMENTS THE TOTAL NUMBER OF NODES CHECKED
        NOGOGO=testroute(TREE, TEMP_NODE, NODE_DIST,0);
        if (TEMP_NODE(2)<CLOSE_NODE(2))
            TEMP_NODE(3)=TREE(TEMP_NODE(3),3);
        end
        %DETERMINING IF TEMPORARY NODE IS INSIDE THE OBSTACLE SPACE
        %if ((TEMP_NODE(1)<OBSTACLE_SPACE(1,1))|| (TEMP_NODE(1)>OBSTACLE_SPACE(2,1))) || ((TEMP_NODE(2)>OBSTACLE_SPACE(1,2))|| (TEMP_NODE(2)<OBSTACLE_SPACE(2,2)))&& (NOGOGO==0)
        if (NOGOGO==0)
            NODES = NODES+ 1;                   %INCREMENT THE NODE COUNTER
            TREE(NODES, :)=TEMP_NODE;           %ADDS THE NODE TO [TREE]
            
            RAND_GO=0;                          %STOPS CHECKING RANDOM NODES
        
        end
        
%         if ITERATIONS>10
%             DONE=1;
%             RAND_GO=0;
%         end

    end
    GOAL_DIST=((GOAL(1)-TREE(NODES,1))^2+(GOAL(2)-TREE(NODES,2))^2)^.5;
    
end

%EXTRACT THE COMPLETED PATH************************************************
CONNECTING_NODE=NODES;     %INITIALIZES THE CONNECTION NODE FROM THE GOAL
FINAL_NODES=0;
while(CONNECTING_NODE>0)
    FINAL_NODES=FINAL_NODES+1;
    FINAL_TREE(FINAL_NODES, :)=TREE(CONNECTING_NODE,1:2);   %MOVES THE PREVIOUS NODE IN THE TREE INTO THE FINAL TREE
    CONNECTING_NODE=TREE(CONNECTING_NODE,3);          %SETS THE NEXT CONNECTING NODE 
    
end


    
%PLOTTING THE DATA*********************************************************
% OBSTACLER(1,1)=OX1;
% OBSTACLER(1,2)=OY1;
% OBSTACLER(2,1)=OX2;
% OBSTACLER(2,2)=OY1;
% OBSTACLER(3,1)=OX2;
% OBSTACLER(3,2)=OY2;
% OBSTACLER(4,1)=OX1;
% OBSTACLER(4,2)=OY2;
% OBSTACLER(5,1)=OX1;
% OBSTACLER(5,2)=OY1;

NODES=NODES+1;
TREE(NODES,1)=GOAL(1);
TREE(NODES,2)=GOAL(2)+NODE_DIST;
TREE(NODES,3)=NODES-1;
NOGOGO=testroute(TREE, TREE(NODES,:), NODE_DIST,1);

plot(FINAL_TREE(1:FINAL_NODES,1),FINAL_TREE(1:FINAL_NODES,2))
hold on
% scatter(TREE(1:NODES,1),TREE(1:NODES,2))
% hold on
% scatter(TOT_TREE(1:TOT_NODES,1),TOT_TREE(1:TOT_NODES,2),'x')
% hold on
% scatter(RAND_TREE(1:RAND_TOT,1),RAND_TREE(1:RAND_TOT,2),'+')
 hold off
